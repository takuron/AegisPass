# AegisPass 算法解析

本文档详细解释了 AegisPass 用于生成确定性密码的核心算法。该算法的设计目标是：安全、确定性、可复现且能满足现代密码的复杂度要求。

整个流程在 `aegis_pass_generator` 函数中实现。

### 核心输入

算法的运作依赖于以下三个核心输入：

1.  **主密码 (`password_source`)**: 用户持有的核心秘密，永不存储。
2.  **区分密钥 (`distinguish_key`)**: 用于为不同服务（如网站或应用）生成不同密码的变量，类似于“盐”。
3.  **预设 (`preset`)**: 一个 JSON 对象，定义了密码生成的所有参数，包括长度、字符集和所用算法。

### 算法流程详解

密码的生成过程可以分为以下几个关键阶段：

#### 阶段 A: 输入验证

在生成开始前，程序会进行严格的输入验证，以防止生成无效或不安全的密码：
1.  确保主密码和区分密钥均不为空。
2.  确保请求的密码长度 (`length`) 必须大于或等于字符集分组的数量 (`charsets.len()`)，否则无法满足每个分组至少出现一次的要求。
3.  确保每个字符集分组内都至少包含一个字符。

#### 阶段 B: 生成主种子 (Master Seed)

这是算法的核心。一个**确定性**的32字节主种子是后续所有伪随机操作的基础。它的生成过程如下 (`generate_master_seed` 函数)：

1.  **拼接输入**: 将多个预设参数和用户输入拼接成一个唯一的长字符串。格式为：
    ```
    "AegisPass_V{version}:{platform_id}:{length}:{password_source}:{distinguish_key}:{charsets_json}"
    ```
    其中 `charsets_json` 是 `charsets` 数组的 JSON 字符串表示。这确保了预设中的任何微小变动都会导致生成完全不同的种子。

2.  **哈希计算**: 对上述拼接的字符串使用预设中指定的哈希算法（如 `sha256` 或 `blake3`）进行哈希计算。

3.  **获取种子**: 将哈希结果作为32字节的**主种子**。

#### 阶段 C: 保证每个字符集至少出现一次

为了满足密码复杂度要求（例如，必须包含数字、大小写字母和特殊符号），算法会确保每个 `charsets` 分组中的字符都至少在密码中出现一次。

1.  **分割种子**: 将32字节的主种子分割成多个4字节（`u32`）的块。
2.  **选择字符**: 对于每一个字符集分组，使用一个对应的4字节块作为种子，通过取模运算 (`%`) 从该分组中确定性地选择一个字符。
3.  **初步组合**: 将这些选出的字符存入一个初始密码数组中。

例如，如果主种子是 `[B1, B2, B3, B4, B5, ...]`，字符集是 `["abc", "123"]`：
-   使用 `[B1, B2, B3, B4]` 从 `"abc"` 中选出一个字符。
-   使用 `[B5, B6, B7, B8]` 从 `"123"` 中选出一个字符。

这一步骤是密码强度和确定性的关键保证。

#### 阶段 D: 填充密码剩余长度

在满足了基本复杂度要求后，需要用更多随机字符填充密码至指定长度。

1.  **创建RNG**: 使用**整个主种子**来初始化一个确定性的随机数生成器 (RNG)，例如 `ChaCha20Rng`。因为种子是固定的，所以这个RNG的行为也是完全可复现的。
2.  **合并与洗牌字符集**: 将所有 `charsets` 分组合并成一个大的字符池，并使用刚刚创建的 RNG 对其进行洗牌。
3.  **填充字符**: 从洗牌后的大字符池中按顺序选择字符，填满密码的剩余长度。

#### 阶段 E: 最终整体洗牌

此时，密码的前几个字符是阶段 C 中确定性选择的字符。为了消除这种可预测性，需要进行最后一次整体洗牌。

1.  **重置RNG**: 再次使用**同一个主种子**初始化一个新的 RNG 实例。这确保了洗牌操作本身也是确定性的。
2.  **最终洗牌**: 使用这个新的 RNG 对包含所有字符的密码数组进行最后一次`shuffle`（Fisher-Yates 算法）。

这确保了保证性字符会随机分布在密码的任何位置，而不是总在开头。

#### 阶段 F: 组合并返回

将最终洗牌后的字符数组组合成一个字符串，并返回给用户。

### 结论

AegisPass 算法通过一个“哈希 -> 种子 -> 确定性RNG”的核心流程，巧妙地将用户的输入转化为一个可复现的伪随机过程。它不仅保证了密码的确定性，还通过阶段性的字符选择与填充，确保了密码的复杂度和安全性。